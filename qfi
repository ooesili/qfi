#!/usr/bin/env perl
use strict; use warnings;
use File::Path 'make_path';
use File::Spec;
use File::Basename;
use Getopt::Std;

# usage and version
$Getopt::Std::STANDARD_HELP_VERSION = 1;
sub main::HELP_MESSAGE {
    print "Usage: $0 [-d] TARGET\n";
    print "       $0 -a TARGET FILENAME\n";
    print "       $0 -r TARGET NEWNAME\n";
    print "       $0 -l [TARGET]\n";
}
sub main::VERSION_MESSAGE {
    print "qfi 0.1\n";
}

my $conf_dir;
$0 = basename $0; # remove path from program name

# first arg is name, second is the file; symlink the file to the name
sub add {
    # check for slashes in target name
    die "$0: illegal target name: `$_[0]'\n" if ($_[0] =~ m|/|);
    my $link = File::Spec->catfile($conf_dir, $_[0]);
    # symlinks act funny with relative paths
    my $file = File::Spec->rel2abs($_[1]);
    symlink $file, $link or die "$0: error creating link for `$_[0]': $!\n"
}

# first arg is name; delete associated link
sub delete {
    my $link = File::Spec->catfile($conf_dir, $_[0]);
    unlink $link or die "$0: error removing target `$_[0]': $!\n";
}

# first arg is name; edit file pointed to by the link assocated with the name
sub edit {
    my ($env_editor, $editor, $link, $file, $uid);
    # follow link
    $link = File::Spec->catfile($conf_dir, $_[0]);
    if (-l $link) { $file = readlink $link; }
    else { die "$0: cannot find target `$_[0]': $!\n"; }
    # see who owns it
    if (-f $file) { $uid = (stat $file)[4]; }
    else { die "$0: cannot stat `$file': $!\n"; }
    # pick editor
    if ($uid == 0) {
        $editor = "sudoedit";
    }
    elsif (defined($env_editor = $ENV{'EDITOR'})) {
        $editor = $env_editor;
    }
    else {
        $editor = "vi";
    }
    # run editor
    exec "$editor $file";
}

# list all defined targets, or the dest of a single link, if specified
sub list {
    # print destination if an argument was given
    if (defined $_[0]) {
        my ($file, $link);
        $file = File::Spec->catfile($conf_dir, $_[0]);
        if (-l $file) { $link = readlink $file; }
        else { die "$0: cannot find target `$_[0]': $!\n"; }
        print "$link\n";
    }
    # otherwise print all of the targets
    else {
        my @files = glob File::Spec->catfile($conf_dir,"*");
        for (sort @files) {
            my $target = fileparse($_);
            printf "$target\n";
        }
    }
}

# rename a target
sub rename {
    chdir $conf_dir;
    die "$0: cannot find target `$_[0]': $!'\n" if (! -l $_[0]);
    # check for slashes in target name
    die "$0: illegal target name: `$_[0]'\n" if ($_[0] =~ m|/|);
    rename $_[0], $_[1];
}

# set appropriate configuration directory and create it if it does not exist
{
    my ($xdg_dir, $home_dir);
    # first see if $XDG_CONFIG_HOME is defined
    if (defined($xdg_dir = $ENV{'XDG_CONFIG_HOME'})) {
        $conf_dir = File::Spec->catdir($xdg_dir, "qfi");
    }
    # then try to build conf_dir path from $HOME
    elsif (defined($home_dir = $ENV{'HOME'})) {
        $conf_dir = File::Spec->catdir($home_dir, ".config", "qfi");
    }
    else {
        warn "$0: \$HOME not set\n";
        exit(1);
    }
    # create configration directory if it doesn't exist
    unless (-d $conf_dir) {
        make_path($conf_dir) or die "$0: cannot create $conf_dir: $!\n";
    }
}

# parse command line options and take action
{
    # simple error reporting function
    sub err {
        warn $_[0] if exists $_[0];
        &main::HELP_MESSAGE;
        exit(2);
    }

    # parse options
    my %opts;
    getopts('adlr', \%opts) or &err;
    # test for number of arguments and options, then call command
    &err("$0: too many options\n")		if keys %opts > 1;
    # add
    if (exists $opts{'a'}) {
        &err("$0: no target specified\n")	if @ARGV < 1;
        &err("$0: no file specified\n")		if @ARGV < 2;
        &err("$0: too many arguments\n")	if @ARGV > 2;
        &add($ARGV[0], $ARGV[1]);
    }
    # delete
    elsif (exists $opts{'d'}) {
        &err("$0: no target specified\n")	if @ARGV < 1;
        &err("$0: too many arguments\n")	if @ARGV > 1;
        &delete($ARGV[0]);
    }
    # list
    elsif (exists $opts{'l'}) {
        &err("$0: too many arguments\n")	if @ARGV > 1;
        &list($ARGV[0]);
    }
    # rename
    elsif (exists $opts{'r'}) {
        &err("$0: no target specified\n")	if @ARGV < 1;
        &err("$0: new name not specified\n")	if @ARGV < 2;
        &err("$0: too many arguments\n")	if @ARGV > 2;
        &rename($ARGV[0], $ARGV[1]);
    }
    # edit
    else {
        &err("$0: no target specified\n")	if @ARGV < 1;
        &err("$0: too many arguments\n")	if @ARGV > 1;
        &edit($ARGV[0])
    }
}
